# 1. 転置インデックスとマッチング

（想定実行時間：それぞれ1分以内）

## 1. ディクショナリ

英語製品データについて、以下の連想配列を構築せよ。ただし、単語はスペースで区切られているものとする（以降の問題でも同じ）。

- キー： `product_title` フィールドに出現する単語。
- 値：その単語の出現回数。ただし、全ての製品における合計とする。

また、単語の異なり数が約90万であることを確かめよ。

## 2. ポスティングリスト

単語 `Information` を `product_title` フィールドに含む製品の `product_id` の配列を出力せよ。ただし、`product_id` は辞書順とし、重複してはならない（以降の問題でも同じ）。

また、この配列の要素数が110であることを確かめよ。

## 3. 転置インデックス

以下の連想配列を構築せよ：

- キー：`product_title` フィールドに出現する単語。
- 値：その単語を `product_title` フィールドに含む製品の `product_id` の配列。

また、この連想配列について、以下のことを確かめよ：

- エントリ数が `1.` の連想配列のそれと等しいこと。
- `Information` に紐づいた配列が `2.` の配列と等しいこと。

以降、このデータ構造を**転置インデックス**、転置インデックスの値を**ポスティングリスト**と呼ぶ。

## 4. 永続化

転置インデックスをメモリからディスクに書き込んだり、ディスクからメモリに読み込んだりできるようにせよ。

## 5. ブーリアンAND検索

転置インデックスを用いて、2単語 `Information` と `Science` を**ともに** `product_title` フィールドに含む製品の `product_id` の配列を出力せよ。ただし、配列が非常に長い場合にも効率的なコードにせよ（以降の問題でも同じ）。

また、この配列の要素数が3であることを確かめよ。

## 6. ブーリアンOR検索

転置インデックスを用いて、2単語 `Information` と `Retrieval` の**少なくとも片方を** `product_title` フィールドに含む製品の `product_id` の配列を出力せよ。

また、この配列の要素数が129であることを確かめよ。

## 7. 条件の否定

`5.` の条件を**満たさず**、かつ、`6.` の条件を満たす製品の `product_id` の配列を出力せよ。

また、この配列の要素数が126であることを確かめよ。

## 8. 完全一致

`product_brand` フィールドに関する転置インデックスを構築せよ。ただし単語に区切らず、フィールドの値をそのまま連想配列のキーとすること。

## 9. 複数フィールドの横断

転置インデックスを用いて、`product_title` フィールドに単語 `Amazon` を含み、かつ、`product_brand` フィールドの値が `Amazon Basics` **ではない**製品の数が8,681であることを確かめよ。
